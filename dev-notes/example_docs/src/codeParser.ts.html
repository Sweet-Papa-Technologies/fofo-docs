<h1 id="srccodeparsertsfofodocs">src/codeParser.ts - fofo-docs</h1>
<p><strong>Summary:</strong> The code aims to parse a codebase (directory or single file) and generate a summary of its contents. It analyzes code files, extracts information like classes, functions, variables, types, interfaces, imports, and exports, and summarizes the code's purpose and features using a large language model (LLM). The code also handles large files by breaking them into chunks and processing them separately.</p>
<ul>
<li><strong>File Location:</strong> ./src/codeParser.ts</li>
<li><strong>Language:</strong> language: TypeScript </li>
</ul>
<h2 id="tableofcontents">Table of Contents</h2>
<ul>
<li><a href="#classes">classes</a></li>
<li><a href="#functions">functions</a></li>
<li><a href="#types">types</a></li>
<li><a href="#imports">imports</a></li>
<li><a href="#interfaces">interfaces</a></li>
</ul>
<h2 id="classes">classes</h2>
<h2 id="codefilesummaryclass">### 📘 CodeFileSummary - CLASS</h2>
<p><strong>Description:</strong> Represents a summary of a code file, including its name, location, language, code summary, execution flow, and code objects.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import {  Embeddings, Metadata, QueryResponse } from "chromadb";

export type CodeObjectType = 'class' | 'function' | 'variable' | 'type' | 'import' | 'export' | 'interface' | 'constructor';
export type CodeObjects = 'classes' | 'functions' | 'variables' | 'types' | 'imports' | 'exports' | 'interfaces' | 'fileName' | 'fileLocation'

export interface globResult {

        "glob": string[],
        "ignore": string[]

}

export interface runtimeData {

    appVersion: string;
    projectName: string;
    projectPath: string;
    outputPath: string;
    selectedLLModel: string | undefined;
    selectedRAGService: string;
}
export interface moduleObject {
    name: string;
    version: string;
    description: string;
}
export interface ProjectSummary {
    projectName: string;
    projectDescription: codeSummary
    projectLocation: string;
    projectTechStackDescription: string,
    projectDependencies: moduleObject[];
    codeFiles: CodeFileSummary[];
    ragData: RagData[];
    teamContext: string;
}

export interface models {
    name: string,
    model: any,
}
export interface modelServiceConfig {
    models: models[],
    endpoint?:string 
}

export interface RagData {
    metadata: {
        filename: string;
        codeChunkId: string|number;
        codeChunkLineStart: number;
        codeChunkLineEnd: number;
        codeObjects: CodeObject;
        codeChunkSummary: string;
    };
    embeddings?: number[][]; // Example: Embeddings could be an array of numbers
    documentData: any
    allSearchResults: QueryResponse,
    allResults: {
        documents: any,
        embeddings: Embeddings[] | null,
        metadatas: (Metadata | null)[][],

    }
}

export interface codeSummary {
    goal: string,
    features_functions: string,
  }
export interface CodeFileSummary {
    fileName: string;
    fileLocation: string;
    codeSummary: codeSummary;
    language: string;
    executionFlow: ExecutionFlow[];
    codeObjects: CodeObject;
}

export interface ExecutionFlow {
    step: number;
    stepDescription: string;
    bImportant: boolean;
    codeSnippet: string;
    codeLine: number;
    codeIndent: number;
    fileName: string;
    fileLocation: string;
}

export interface FunctionParameter {
    name: string;
    type: string;
    description: string;
    example: string;
}

export interface FunctionReturn {
    type: string;
    description: string;
    example: string;
}

export interface CodeObject {
    name: string;
    type: CodeObjectType;
    description: string;
    codeSnippet: string;
    annotation?: Annotation;
    codeLine?: number;
    codeIndent?: number;
    content?:string;
    fileName: string;
    fileLocation: string;
    subObjects?: CodeObject[];
    parentObject?: CodeObject;
    functionParameters?: FunctionParameter[];
    functionReturns?: FunctionReturn;
    isExported: boolean;
    isFunction: boolean;
    isClass: boolean;
    isPrivate: boolean;
    isAsync: boolean;
}

export type CodeObjectTypes = 'name' | 'type' | 'description' | 'codeSnippet' | 'codeLine' | 'codeIndent' | 'fileName' | 'fileLocation' | 'subObjects' | 'parentObject' | 'functionParameters' | 'functionReturns' | 'isExported' | 'isFunction' | 'isClass' | 'isPrivate' | 'isAsync'

export interface Annotation {
    purpose: string;
    parameters?: string;
    returns?: string;
    usageExample?: string;
    edgeCases?: string;
    dependencies?: string;
    errorHandling?: string;
    performance?: string;
    bestPractices?: string;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>CodeFileSummary</code> interface represents a summary of a code file, encompassing its name, location, language, code summary, execution flow, and code objects.</li>
<li><strong>Parameters:</strong> N/A</li>
<li><strong>Returns:</strong> N/A</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const codeFileSummary: CodeFileSummary = {
  fileName: "myFile.ts",
  fileLocation: "./myFile.ts",
  codeSummary: {
    goal: "This file implements a function to calculate the sum of two numbers.",
    features_functions: "The function takes two numbers as input and returns their sum."
  },
  language: "TypeScript",
  executionFlow: [],
  codeObjects: {}
};
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> N/A</li>
<li><strong>Dependencies:</strong> The interface relies on the <code>codeSummary</code>, <code>ExecutionFlow</code>, and <code>CodeObject</code> interfaces.</li>
</ul>
<h2 id="projectsummaryclass">### 📘 ProjectSummary - CLASS</h2>
<p><strong>Description:</strong> Represents a summary of a project, including its name, description, dependencies, location, tech stack description, code files, RAG data, and team context.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import {  Embeddings, Metadata, QueryResponse } from "chromadb";

export type CodeObjectType = 'class' | 'function' | 'variable' | 'type' | 'import' | 'export' | 'interface' | 'constructor';
export type CodeObjects = 'classes' | 'functions' | 'variables' | 'types' | 'imports' | 'exports' | 'interfaces' | 'fileName' | 'fileLocation'

export interface globResult {

        "glob": string[],
        "ignore": string[]

}

export interface runtimeData {

    appVersion: string;
    projectName: string;
    projectPath: string;
    outputPath: string;
    selectedLLModel: string | undefined;
    selectedRAGService: string;
}
export interface moduleObject {
    name: string;
    version: string;
    description: string;
}
export interface ProjectSummary {
    projectName: string;
    projectDescription: codeSummary
    projectLocation: string;
    projectTechStackDescription: string,
    projectDependencies: moduleObject[];
    codeFiles: CodeFileSummary[];
    ragData: RagData[];
    teamContext: string;
}

export interface models {
    name: string,
    model: any,
}
export interface modelServiceConfig {
    models: models[],
    endpoint?:string 
}

export interface RagData {
    metadata: {
        filename: string;
        codeChunkId: string|number;
        codeChunkLineStart: number;
        codeChunkLineEnd: number;
        codeObjects: CodeObject;
        codeChunkSummary: string;
    };
    embeddings?: number[][]; // Example: Embeddings could be an array of numbers
    documentData: any
    allSearchResults: QueryResponse,
    allResults: {
        documents: any,
        embeddings: Embeddings[] | null,
        metadatas: (Metadata | null)[][],

    }
}

export interface codeSummary {
    goal: string,
    features_functions: string,
  }
export interface CodeFileSummary {
    fileName: string;
    fileLocation: string;
    codeSummary: codeSummary;
    language: string;
    executionFlow: ExecutionFlow[];
    codeObjects: CodeObject;
}

export interface ExecutionFlow {
    step: number;
    stepDescription: string;
    bImportant: boolean;
    codeSnippet: string;
    codeLine: number;
    codeIndent: number;
    fileName: string;
    fileLocation: string;
}

export interface FunctionParameter {
    name: string;
    type: string;
    description: string;
    example: string;
}

export interface FunctionReturn {
    type: string;
    description: string;
    example: string;
}

export interface CodeObject {
    name: string;
    type: CodeObjectType;
    description: string;
    codeSnippet: string;
    annotation?: Annotation;
    codeLine?: number;
    codeIndent?: number;
    content?:string;
    fileName: string;
    fileLocation: string;
    subObjects?: CodeObject[];
    parentObject?: CodeObject;
    functionParameters?: FunctionParameter[];
    functionReturns?: FunctionReturn;
    isExported: boolean;
    isFunction: boolean;
    isClass: boolean;
    isPrivate: boolean;
    isAsync: boolean;
}

export type CodeObjectTypes = 'name' | 'type' | 'description' | 'codeSnippet' | 'codeLine' | 'codeIndent' | 'fileName' | 'fileLocation' | 'subObjects' | 'parentObject' | 'functionParameters' | 'functionReturns' | 'isExported' | 'isFunction' | 'isClass' | 'isPrivate' | 'isAsync'

export interface Annotation {
    purpose: string;
    parameters?: string;
    returns?: string;
    usageExample?: string;
    edgeCases?: string;
    dependencies?: string;
    errorHandling?: string;
    performance?: string;
    bestPractices?: string;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-1">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>ProjectSummary</code> class represents a comprehensive summary of a software project, encompassing various aspects like project name, description, dependencies, location, technology stack, code files, RAG data, and team context.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const projectSummary: ProjectSummary = {
  projectName: "MyProject",
  projectDescription: {
    goal: "This project aims to...",
    features_functions: "Key features include..."
  },
  projectLocation: "/path/to/project",
  projectTechStackDescription: "TypeScript, React, Node.js",
  projectDependencies: [
    { name: "react", version: "18.2.0" },
    { name: "express", version: "4.18.2" }
  ],
  codeFiles: [
    // ... code file summaries
  ],
  ragData: [
    // ... RAG data
  ],
  teamContext: "This project is developed by..."
};
</code></pre>
<ul>
<li><p><strong>Dependencies:</strong> The <code>ProjectSummary</code> class relies on the following interfaces and types from the <code>objectSchemas</code> module:</p></li>
<li><p><code>codeSummary</code></p></li>
<li><p><code>CodeFileSummary</code></p></li>
<li><p><code>RagData</code></p></li>
<li><p><code>moduleObject</code></p></li>
<li><p><code>CodeObjectType</code></p></li>
<li><p><code>CodeObjects</code></p></li>
<li><p><code>globResult</code></p></li>
<li><p><code>runtimeData</code></p></li>
<li><p><code>models</code></p></li>
<li><p><code>modelServiceConfig</code></p></li>
<li><p><code>ExecutionFlow</code></p></li>
<li><p><code>FunctionParameter</code></p></li>
<li><p><code>FunctionReturn</code></p></li>
<li><p><code>CodeObject</code></p></li>
<li><p><code>CodeObjectTypes</code></p></li>
<li><p><code>Annotation</code></p></li>
</ul>
<h2 id="runtimedataclass">### 📘 runtimeData - CLASS</h2>
<p><strong>Description:</strong> Represents runtime data for the FoFo Docs application, including version, project name, paths, and selected models.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import {  Embeddings, Metadata, QueryResponse } from "chromadb";

export type CodeObjectType = 'class' | 'function' | 'variable' | 'type' | 'import' | 'export' | 'interface' | 'constructor';
export type CodeObjects = 'classes' | 'functions' | 'variables' | 'types' | 'imports' | 'exports' | 'interfaces' | 'fileName' | 'fileLocation'

export interface globResult {

        "glob": string[],
        "ignore": string[]

}

export interface runtimeData {

    appVersion: string;
    projectName: string;
    projectPath: string;
    outputPath: string;
    selectedLLModel: string | undefined;
    selectedRAGService: string;
}
export interface moduleObject {
    name: string;
    version: string;
    description: string;
}
export interface ProjectSummary {
    projectName: string;
    projectDescription: codeSummary
    projectLocation: string;
    projectTechStackDescription: string,
    projectDependencies: moduleObject[];
    codeFiles: CodeFileSummary[];
    ragData: RagData[];
    teamContext: string;
}

export interface models {
    name: string,
    model: any,
}
export interface modelServiceConfig {
    models: models[],
    endpoint?:string 
}

export interface RagData {
    metadata: {
        filename: string;
        codeChunkId: string|number;
        codeChunkLineStart: number;
        codeChunkLineEnd: number;
        codeObjects: CodeObject;
        codeChunkSummary: string;
    };
    embeddings?: number[][]; // Example: Embeddings could be an array of numbers
    documentData: any
    allSearchResults: QueryResponse,
    allResults: {
        documents: any,
        embeddings: Embeddings[] | null,
        metadatas: (Metadata | null)[][],

    }
}

export interface codeSummary {
    goal: string,
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> undefined (Unable to Load)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-2">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>runtimeData</code> class represents runtime data for the FoFo Docs application. It stores information such as the application version, project name, file paths, and selected language models and RAG services.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const runtimeData: runtimeData = {
  appVersion: "1.2.0-alpha5",
  projectName: "fofo-docs",
  projectPath: "./",
  outputPath: "./output",
  selectedLLModel: "gpt-4o",
  selectedRAGService: "GCP"
};
</code></pre>
<ul>
<li><strong>Dependencies:</strong> The <code>runtimeData</code> class depends on the <code>chromadb</code> library for embedding and searching data in a vector database.</li>
</ul>
<h2 id="functions">functions</h2>
<h2 id="promptuserfunction">### 🔧 promptUser - FUNCTION</h2>
<p><strong>Description:</strong> Function to prompt user for input</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">const promptUser = (question:string) =&gt; {
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });

    return new Promise((resolve) =&gt; {
        rl.question(question, (answer) =&gt; {
            resolve(answer);
            rl.close();
        });
    })
};
</code></pre>
<ul>
<li><strong>Line:</strong> 46</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> true</li>
<li><strong>Private:</strong> false</li>
<li><strong>Async:</strong> true</li>
</ul>
<h6 id="functionparameters">Function Parameters:</h6>
<ul>
<li><strong>question</strong> (string): The question to ask the user 
Example: 'What is your name?'</li>
</ul>
<h6 id="functionreturns">Function Returns:</h6>
<ul>
<li><strong>Type:</strong> Promise<string></li>
<li><strong>Description:</strong> A promise that resolves to the user's answer</li>
<li><strong>Example:</strong> 'John Doe'</li>
</ul>
<h6 id="annotationscomments-3">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>promptUser</code> function is designed to prompt the user for input using the <code>readline</code> module. It creates a readline interface, asks the user a question, and returns a promise that resolves to the user's answer.</li>
<li><strong>Parameters:</strong> The function takes a single parameter, <code>question</code>, which is a string representing the question to ask the user.</li>
<li><strong>Returns:</strong> The function returns a promise that resolves to the user's answer as a string.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const userName = await promptUser('What is your name?');
console.log(`Hello, ${userName}!`);
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> The function does not handle any specific edge cases. It assumes that the user will provide a valid input.</li>
<li><strong>Dependencies:</strong> The function depends on the <code>readline</code> module for interacting with the user's input.</li>
</ul>
<h2 id="gencodechunkobjfunction">### 🔧 genCodeChunkObj - FUNCTION</h2>
<p><strong>Description:</strong> Process each chunk's code objects (update projectSummary.ragData, etc.)</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">async function genCodeChunkObj(projectSummary:ProjectSummary, filePath:string, chunk:string):Promise&lt;CodeObject&gt;{
    // Process each chunk's code objects (update projectSummary.ragData, etc.)
    const objectKeys:CodeObjects[] = ['classes', 'functions', 'variables', 'types', 'interfaces', 'imports', 'exports']
    const chunkCodeObjectsAny = {} as any;


    for (const key of objectKeys) {

    let promptTemplate = ""

    switch (key) {
        case 'classes':
            promptTemplate = classesPrompt(projectSummary.teamContext, "&lt;relevant code&gt;", filePath, chunk, key)
            break;
        case 'functions':
            promptTemplate = functionsPrompt(projectSummary.teamContext, "&lt;relevant code&gt;", filePath, chunk, key)
            break;
        case 'variables':
            promptTemplate = variablesPrompt(projectSummary.teamContext, "&lt;relevant code&gt;", filePath, chunk, key)
            break;
        case 'types':
            promptTemplate = typesPrompt(projectSummary.teamContext, "&lt;relevant code&gt;", filePath, chunk, key)
            break;
        case 'interfaces':
            promptTemplate = interfacesPrompt(projectSummary.teamContext, "&lt;relevant code&gt;", filePath, chunk, key)
            break;
        // case 'comments':
        //     promptTemplate = commentsPrompt(projectSummary.teamContext, "&lt;relevant code&gt;", filePath, chunk, key)
        //     break;
        case 'imports':
            promptTemplate = importsPrompt(projectSummary.teamContext, "&lt;relevant code&gt;", filePath, chunk, key)
            break;
        case 'exports':
            promptTemplate = exportsPrompt(projectSummary.teamContext, "&lt;relevant code&gt;", filePath, chunk, key)
            break;
        default:
            console.error("Error: Invalid object key")
            break;
    }

    const bRag = process.env.EMBEDDER_MODE === 'OFF' ? false : true

    const codeObjects = await callLLM(
        promptTemplate,
        projectSummary,
        chunk,
        filePath,
        bRag,
        llmToUse
      );

     // insert the object into the chunkCodeObjects
     chunkCodeObjectsAny[key] = codeObjects[key];
    }

    const chunkCodeObjects = chunkCodeObjectsAny as CodeObject;

    return chunkCodeObjects;
}
</code></pre>
<ul>
<li><strong>Line:</strong> 60</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> false</li>
<li><strong>Private:</strong> false</li>
<li><strong>Async:</strong> true</li>
</ul>
<h6 id="functionparameters-1">Function Parameters:</h6>
<ul>
<li><strong>projectSummary</strong> (ProjectSummary): The project summary object 
Example: {}</li>
<li><strong>filePath</strong> (string): The path to the file 
Example: './src/codeParser.ts'</li>
<li><strong>chunk</strong> (string): The chunk of code to process 
Example: '// This is a chunk of code'</li>
</ul>
<h6 id="functionreturns-1">Function Returns:</h6>
<ul>
<li><strong>Type:</strong> Promise<CodeObject></li>
<li><strong>Description:</strong> A promise that resolves to the code object</li>
<li><strong>Example:</strong> {}</li>
</ul>
<h6 id="annotationscomments-4">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This function processes each chunk of code in a file and extracts code objects like classes, functions, variables, types, interfaces, imports, and exports. It uses a prompt template based on the type of code object to generate a prompt for the LLM, which then identifies and describes the code objects within the chunk. The function then merges the extracted code objects into a single CodeObject and returns it.</li>
<li><strong>Parameters:</strong> - projectSummary: The ProjectSummary object containing information about the project, including team context and other relevant data.</li>
<li>filePath: The path to the file containing the code chunk.</li>
<li>chunk: The code chunk to be processed.</li>
<li><strong>Returns:</strong> A Promise that resolves to a CodeObject containing the extracted code objects from the chunk.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const codeChunk = "// This is a chunk of code";
const codeObject = await genCodeChunkObj(projectSummary, './src/codeParser.ts', codeChunk);
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> If the code chunk contains invalid syntax or if the LLM fails to identify code objects, the function may return an empty CodeObject or an error.</li>
<li><strong>Dependencies:</strong> - classesPrompt, functionsPrompt, variablesPrompt, typesPrompt, interfacesPrompt, importsPrompt, exportsPrompt: Functions that generate prompts for the LLM based on the type of code object.</li>
<li>callLLM: Function that calls the LLM with the generated prompt and returns the response.</li>
</ul>
<h2 id="mergeobjectarraysfunction">### 🔧 mergeObjectArrays - FUNCTION</h2>
<p><strong>Description:</strong> Merge incoming codeObj's key-array pairs with the existing codeObjArray</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">export function mergeObjectArrays(
  codeObjArray: CodeObject,
  newCodeObj: any
): CodeObject {
  // We need to merge our incoming codeObj's key-array pairs with the existing codeObjArray
  // If the key already exists, we need to merge the arrays
  // If the key does not exist, we need to add it to the codeObjArray
  const mergedCodeObj: any = codeObjArray;
  for (const key in newCodeObj) {

    // if the current key is a string, skip it
    if (typeof newCodeObj[key] === "string" || newCodeObj[key] instanceof String) {
      continue;
    }
    if (typeof mergedCodeObj[key] === "string" || mergedCodeObj[key] instanceof String) {
      console.warn("Error: Code Object is not an object");
      console.debug(newCodeObj[key]);
      continue;
    }

    if (key in mergedCodeObj) {
      if (Array.isArray(mergedCodeObj[key]) &amp;&amp; Array.isArray(newCodeObj[key])){
        mergedCodeObj[key] = [...mergedCodeObj[key], ...newCodeObj[key]];
      } else{
        console.error("Not an Array?")
      }

    } else {
      mergedCodeObj[key] = newCodeObj[key];
    }
  }

  // Delete any duplicate code objects:
  console.log("Deleting Duplicate Code Objects");
  const mergedCodeKeys = Object.keys(mergedCodeObj);
    for (const key of mergedCodeKeys) {

    const foundKeys: string[] = [];

    // Make sure the key object is iterable
    if (!Array.isArray(mergedCodeObj[key])) {
      console.warn("Error: Code Object is not an array");
      console.log(mergedCodeObj[key]);
      continue;
    }

    for (const arrayObj of mergedCodeObj[key]) {
      if ("name" in arrayObj) {
        if (foundKeys.includes(arrayObj.name)) {
          mergedCodeObj[key] = mergedCodeObj[key].filter(
            (obj: any) =&gt; obj.name !== arrayObj.name
          );
        } else {
          foundKeys.push(arrayObj.name);
        }
      } else if ("content" in arrayObj) {
        if (foundKeys.includes(arrayObj.content)) {
          mergedCodeObj[key] = mergedCodeObj[key].filter(
            (obj: any) =&gt; obj.content !== arrayObj.content
          );
        } else {
          foundKeys.push(arrayObj.content);
        }
      } else {
        console.warn("Error: Code Object has no name or content property");
        continue;
      }
    }
  }
  return mergedCodeObj;
}
</code></pre>
<ul>
<li><strong>Line:</strong> 121</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> true</li>
<li><strong>Private:</strong> false</li>
<li><strong>Async:</strong> false</li>
</ul>
<h6 id="functionparameters-2">Function Parameters:</h6>
<ul>
<li><strong>codeObjArray</strong> (CodeObject): The existing code object array 
Example: {}</li>
<li><strong>newCodeObj</strong> (any): The new code object to merge 
Example: {}</li>
</ul>
<h6 id="functionreturns-2">Function Returns:</h6>
<ul>
<li><strong>Type:</strong> CodeObject</li>
<li><strong>Description:</strong> The merged code object array</li>
<li><strong>Example:</strong> {}</li>
</ul>
<h6 id="annotationscomments-5">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This function merges two code objects, combining their key-value pairs. It handles merging arrays by concatenating them and removes duplicate code objects based on their 'name' or 'content' properties.</li>
<li><strong>Parameters:</strong> - codeObjArray: CodeObject - The existing code object array.</li>
<li>newCodeObj: any - The new code object to merge.</li>
<li><strong>Returns:</strong> CodeObject - The merged code object array.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const codeObj1: CodeObject = {
  classes: [{
    name: 'ClassA',
    type: 'class',
    description: 'Class A description',
    codeSnippet: 'class ClassA { ... }',
    codeLine: 10,
    codeIndent: 0,
    fileName: 'file1.ts',
    fileLocation: './src/file1.ts',
    subObjects: []
  }]
};

const codeObj2: any = {
  classes: [{
    name: 'ClassB',
    type: 'class',
    description: 'Class B description',
    codeSnippet: 'class ClassB { ... }',
    codeLine: 20,
    codeIndent: 0,
    fileName: 'file2.ts',
    fileLocation: './src/file2.ts',
    subObjects: []
  }]
};

const mergedCodeObj = mergeObjectArrays(codeObj1, codeObj2);
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> The function assumes that the 'codeObjArray' is a valid CodeObject and that the 'newCodeObj' is an object. It also assumes that the arrays to be merged are arrays of objects with either a 'name' or 'content' property for duplicate detection.</li>
<li><strong>Dependencies:</strong> None</li>
</ul>
<h2 id="parsecodebasefunction">### 🔧 parseCodebase - FUNCTION</h2>
<p><strong>Description:</strong> Parse the codebase and generate a ProjectSummary object</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">export async function parseCodebase(
  projectPath: string,
  projectName: string
): Promise&lt;ProjectSummary&gt; {
  const projectSummary: ProjectSummary = {
    projectName: projectName,
    projectDescription: {} as codeSummary,
    projectDependencies: [],
    projectLocation: projectPath,
    projectTechStackDescription: "",
    codeFiles: [],
    ragData: [],
    teamContext: "",
  };

  // Clean projectPath of any trailing slashes or " characters
  projectPath = projectPath.replace(/\$/, "");
  projectPath = projectPath.replace(/\\$/g, "");
  projectPath = projectPath.replace(/"/g, "");

  const ignorePatterns = [
    "**/node_modules",
    "node_modules",
    "dist",
    "*/node_modules/**",
    "*/dist/**",
    "node_modules/**",
    "dist/**",
    ...(await getIgnoredFiles(projectPath)),
  ];

  projectSummary.teamContext = getContextFromFile(); 
  console.log("Team/Project Context:
", projectSummary.teamContext)

  let filePaths: string[] = [];
  let bIsDir = false
  // Determine if the projectPath is a directory or a file

  if (fs.lstatSync(projectPath).isDirectory()) {

    filePaths = await glob(["**/*", "*"], {
      cwd: projectPath,
      ignore: ignorePatterns,
    });
    bIsDir = true
  } else {
    const file = projectPath.split("/").pop();
    projectPath = projectPath.split("/").slice(0, -1).join("/");

    if (!file) {
      throw new Error("Invalid file path");
    }
    filePaths = [file];
  }

  // Determine the general information about the project, and determine if there are any package dependencies, etc:
  if (bIsDir === true) {
  const filePathsTruncated = filePaths.length &gt; 500 ? filePaths.slice(0, 500) : filePaths;
  console.log("===&gt; Determining Project Stack and Dependencies:

");
  console.log("Files to Determine Stack:", filePathsTruncated.length);
  //console.debug(filePathsTruncated)
  const projectStackLang = await infer(
    determineProjectStack(filePathsTruncated),
    "TEXT STRING",
    undefined,
    false,
    undefined,
    undefined,
    llmToUse
  ) as any;

  projectSummary.projectTechStackDescription = projectStackLang.response;

  console.log("Project Stack Language:", projectStackLang.response);

  // const associatedDependencyFiles = await infer(
  //   getPackageDependenciesBasedOnLanguage(projectStackLang.response),
  //   "JSON object",
  //   undefined,
  //   false,
  //   undefined,
  //   undefined,
  //   llmToUse
  // ) as globResult;

  // const detectedGlobs = await infer(
  //   getGlobsBasedOnLangStack(projectStackLang.response),
  //   "JSON object",
  //   undefined,
  //   false,
  //   undefined,
  //   undefined,
  //   llmToUse
  // ) as globResult;

  // console.log("Detected Globs:", detectedGlobs.glob);
  // console.log("Detected Ignore Patterns:", detectedGlobs.ignore);
  // Search for the specific files the LLM decided we should look for:

  // Update Files Paths to Include LLM Result:
  const ignoreMeh = await getIgnoredFiles(projectPath)
  filePaths = await glob(["**/*.{ts,js,tsx,jsx}", ...fofoDocsBuiltInFileSearch], {
    cwd: projectPath,
    ignore: [...ignorePatterns],
  }).then((res) =&gt; {
    console.log("All Files LEN:", res.length);
    return res.filter((file) =&gt; isNoNoFile(file) === false);
  });

  console.debug(filePaths)
  console.log("POST Filter Files to Process LEN:", filePaths.length);

  console.log("Searching for Dependency Files:", fofoDocsBuiltInGlobSearch)
  console.log("Ignoring Files:", ignorePatterns)

  const dependencyFiles = await glob(fofoDocsBuiltInGlobSearch, {
    cwd:projectPath,
    ignore: ignorePatterns,
  })
  .then((res) =&gt; {
    console.log("Dependency Files Found (PRIOR):", res);
    return res.filter((file) =&gt; isNoNoFile(file, ignoreMeh) === false);
  });

  console.log("Dependency Files Found:", dependencyFiles);

  // Process each dependency file:
  for (const depFileName of dependencyFiles) {
    const depFile = `${projectPath}/${depFileName}`;
    console.log("Processing Dependency File:", depFile);
    const depFileContent = await readFile(`${depFile}`, "utf-8");
    const relevantPackagesModules = await infer(
      determineModulesPackagesFromFile(depFileContent),
      "JSON object",
      undefined,
      false,
      undefined,
      undefined,
      llmToUse
    ) as moduleObject;

    projectSummary.projectDependencies.push(relevantPackagesModules);
  }

  // if the result array is nested, or it is an array of arrays, we need to flatten it
  projectSummary.projectDependencies = projectSummary.projectDependencies.flat(1);

}

console.log(filePaths)
  // Process Each File!
  console.log("===&gt; Processing Code Files:

");
  console.log("Files to Process:", filePaths.length);

  // pause for a moment so user can see
  await new Promise((resolve) =&gt; setTimeout(resolve, 5000));

  const warnIfOverValue = Number(process.env.WARN_IF_OVER || "100");
  console.log("Warn if over value:", warnIfOverValue);

  if (filePaths.length === 0) {
    console.log("No files to process, exiting...");
    return projectSummary;
  }

  if (filePaths.length &gt; warnIfOverValue) {
    console.warn("Warning: Large number of files to process, this may take a while...");

    // Prompt to see if they want to continue:
    const bContinue = await promptUser("Continue processing files? (y/n): ") as string;
    if (bContinue?.toLocaleLowerCase() !== "y") {
      console.log("Exiting...");
      return projectSummary;
    } else {
      console.log("ALRIGHT, LET'S CONTINUE...");
    }
  }

  const processFile = async (filePath: string) =&gt; {
    console.log(`Parsing file: ${filePath}`);
    const fullFilePath = `${projectPath}/${filePath}`;

    const fileLanguage = await infer(
      getLanguageTypeFromFile(fullFilePath),
      "TEXT STRING",
      "language",
      false,
      undefined,
      undefined,
      llmToUse
    );
    console.log("fileLanguage", fileLanguage.language);
    const codeFileSummary: CodeFileSummary = {
      fileName: filePath,
      fileLocation: fullFilePath,
      codeSummary: {} as codeSummary, // Placeholder, will be updated later
      language: fileLanguage.language || "Unknown",
      executionFlow: [], // Placeholder, will be updated later
      codeObjects: {} as CodeObject, // Placeholder, will be updated later
    };
    let currentLine = 0;

    if ((await isFileTooLarge(fullFilePath, 3000, breakNum)) == true) {
      // 750KB is the default limit
      // Handle large files by breaking into chunks and processing separately
      const fileContent = await readFile(fullFilePath, "utf-8");
      const codeChunks = breakCodeIntoChunks(fileContent, breakNum); // 1000 tokens per chunk
      const getCurrentLineEndLineBasedOnChunk = (chunk: string) =&gt; {
        const lines = chunk.split("\n");
        return {
          start: currentLine,
          end: currentLine + lines.length,
        };
      };
      console.log("Code broken into codeChunks length =", codeChunks.length);
      for (const [index, chunk] of codeChunks.entries()) {
        console.log(
          "Processing chunk:",
          index + 1,
          "of ",
          codeChunks.length,
          " chunks for file ",
          filePath
        );
        const endLine = getCurrentLineEndLineBasedOnChunk(chunk).end;

        const chunkCodeObjects = await genCodeChunkObj(projectSummary, fullFilePath, chunk)
        .then(
          (res) =&gt; {

            try {
              const codeLineUpdatedObject =  findCorrectCodeLineForObject(res, chunk)
              if (codeLineUpdatedObject.codeLine){
                codeLineUpdatedObject.codeLine = codeLineUpdatedObject.codeLine + currentLine
                return codeLineUpdatedObject 
              }
            } catch (err) {
              console.error("Error finding correct code line for object", err);
          }
          return res
        });

        // Update the Data with correct line information:

        const ragData: RagData = {
          metadata: {
            filename: fullFilePath,
            codeChunkId: index,
            codeChunkLineStart: currentLine,
            codeChunkLineEnd: endLine,
            codeObjects: chunkCodeObjects,
            codeChunkSummary: chunkCodeObjects.description,
          },
          documentData: chunk,
          allSearchResults: {
            ids: [],
            embeddings: null,
            documents: [],
            metadatas: [],
            distances: null
          },
          allResults: {
            documents: undefined,
            embeddings: null,
            metadatas: []
          }
        };

        projectSummary.ragData.push(ragData);

        codeFileSummary.codeObjects = mergeObjectArrays(
          codeFileSummary.codeObjects,
          chunkCodeObjects
        );
        codeFileSummary.codeSummary = await getCodeSummaryFromLLM(
          chunk,
          llmToUse
        );

        await saveToVectorDatabase(projectName, chunk, ragData);

        currentLine = endLine;
      }
    } else {
      const fileContent = await readFile(fullFilePath, "utf-8");
      const codeObjects = await genCodeChunkObj(projectSummary, fullFilePath, fileContent)
      .then(
        (res) =&gt; {

          try {
            const codeLineUpdatedObject =  findCorrectCodeLineForObject(res, fileContent)
            return codeLineUpdatedObject 

          } catch (err) {
            console.error("Error finding correct code line for object", err);

        }
        return res
      });
      // Process code objects and update projectSummary and codeFiles

      // Process each chunk's code objects (update projectSummary.ragData, etc.)
      const ragData: RagData = {
        metadata: {
          filename: fullFilePath,
          codeChunkId: 0,
          codeChunkLineStart: 1,
          codeChunkLineEnd: getTotalLines(fileContent),
          codeObjects: codeObjects,
          codeChunkSummary: codeObjects.description,
        },
        documentData: fileContent,
        allSearchResults: {
          ids: [],
          embeddings: null,
          documents: [],
          metadatas: [],
          distances: null
        },
        allResults: {
          documents: undefined,
          embeddings: null,
          metadatas: []
        }
      };

      projectSummary.ragData.push(ragData); 

      await saveToVectorDatabase(projectName, fileContent, ragData);

      codeFileSummary.codeObjects = mergeObjectArrays(
        codeFileSummary.codeObjects,
        codeObjects
      );
      codeFileSummary.codeSummary = await getCodeSummaryFromLLM(
        fileContent,
        llmToUse
      );
    }

    // WE need to define the overall execution flow here, with another LLM call?

    projectSummary.codeFiles.push(codeFileSummary);
  }


  // TODO=&gt; Implement DIS
  // Divide the files array into separate arrays based on the number of calls we can make per minute
  // const fileJobs=[]
  // const maxFilesPerJob = maxCallsPerMin
  // for (let i = 0; i &lt; filePaths.length; i += maxFilesPerJob) {
  //   fileJobs.push(filePaths.slice(i, i + maxFilesPerJob));
  // }

  // console.log("Number of File Jobs:", fileJobs.length);

  // for (const job of fileJobs) {
  //   await Promise.all(job.map((filePath) =&gt; processFile(filePath)));
  // }


  for (const filePath of filePaths) {
    await processFile(filePath);
  }

  let codeDescription = '';
    for (const codeFile of projectSummary.codeFiles) {

        codeDescription += `## ${codeFile.fileName}
`;
        codeDescription += codeFile.codeSummary.goal + "\n" + 
        codeFile.codeSummary.features_functions + "\n\n";
    }
  projectSummary.projectDescription = 
    await getCodeSummaryFromLLM(
      "# Summaries of Code Files: \n" + codeDescription,
      llmToUse
    )


  return projectSummary;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> true</li>
<li><strong>Private:</strong> false</li>
<li><strong>Async:</strong> true</li>
</ul>
<h6 id="functionparameters-3">Function Parameters:</h6>
<ul>
<li><strong>projectPath</strong> (string): The path to the project 
Example: './src'</li>
<li><strong>projectName</strong> (string): The name of the project 
Example: 'My Awesome Project'</li>
</ul>
<h6 id="functionreturns-3">Function Returns:</h6>
<ul>
<li><strong>Type:</strong> Promise<ProjectSummary></li>
<li><strong>Description:</strong> A promise that resolves to the project summary object</li>
<li><strong>Example:</strong> {}</li>
</ul>
<h6 id="annotationscomments-6">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>parseCodebase</code> function is responsible for parsing a codebase (a directory or a single file) and generating a <code>ProjectSummary</code> object that contains information about the project, its dependencies, and its code files.</li>
<li><strong>Parameters:</strong> - <code>projectPath</code>: The path to the project directory or file to be parsed.</li>
<li><code>projectName</code>: The name of the project.</li>
<li><strong>Returns:</strong> A <code>ProjectSummary</code> object containing information about the project, its dependencies, and its code files.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const projectSummary = await parseCodebase('./src', 'My Awesome Project');
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> - The function handles large files by breaking them into chunks and processing them separately.</li>
<li>It also handles cases where the project path is a directory or a single file.</li>
<li><strong>Dependencies:</strong> - <code>glob</code>: For finding files in a directory.</li>
<li><code>fs/promises</code>: For reading files.</li>
<li><code>objectSchemas</code>: For defining the <code>ProjectSummary</code> and other related objects.</li>
<li><code>llmInterface</code>: For calling the LLM to infer language type, project stack, and dependencies.</li>
<li><code>prompt</code>: For generating prompts for the LLM.</li>
<li><code>vectorDB</code>: For saving code snippets to the vector database.</li>
<li><code>shared</code>: For utility functions like breaking code into chunks, getting token counts, and colorizing text.</li>
</ul>
<h2 id="findcorrectcodelineforobjectfunction">### 🔧 findCorrectCodeLineForObject - FUNCTION</h2>
<p><strong>Description:</strong> Find the correct code line for each object</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">export function findCorrectCodeLineForObject(codeObj: CodeObject, code: string): CodeObject {
  // Split the entire code into lines
  const codeLines = code.split("\n");

  // Function to find the start line of a code snippet with fuzzy matching
  const findStartLine = (snippetLines: string[], codeLines: string[]): number =&gt; {
      for (let i = 0; i &lt; codeLines.length; i++) {
          let match = true;
          for (let j = 0; j &lt; snippetLines.length; j++) {
              if (i + j &gt;= codeLines.length || !codeLines[i + j].includes(snippetLines[j].trim())) {
                  match = false;
                  break;
              }
          }
          if (match) {
              return i + 1; // Line numbers are 1-based
          }
      }
      return -1; // Not found
  };

  // Find the correct code line for each object
  for (const key in codeObj) {
      const codeObject = codeObj as any;
      try {
        for (const objects of codeObject[key]) {
          const obj = objects as CodeObject;
          const codeSnippet = removeCodeBlockIfPresent(obj.codeSnippet)
          const snippetLines = codeSnippet.split("\n");

          const startLine = findStartLine(snippetLines, codeLines);
          obj.codeLine = startLine !== -1 ? startLine : -2;


      }

      } catch(err) {
          console.error("Error finding correct code line for object", err);
          console.debug("Code Object:", codeObj);
          console.debug("Code Object Key:", codeObject[key]);
          continue
      }
  }
  return codeObj;
}
</code></pre>
<ul>
<li><strong>Line:</strong> 575</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> true</li>
<li><strong>Private:</strong> false</li>
<li><strong>Async:</strong> false</li>
</ul>
<h6 id="functionparameters-4">Function Parameters:</h6>
<ul>
<li><strong>codeObj</strong> (CodeObject): The code object to find the line number for 
Example: {}</li>
<li><strong>code</strong> (string): The code to search 
Example: '// This is a chunk of code'</li>
</ul>
<h6 id="functionreturns-4">Function Returns:</h6>
<ul>
<li><strong>Type:</strong> CodeObject</li>
<li><strong>Description:</strong> The code object with the updated code line</li>
<li><strong>Example:</strong> {}</li>
</ul>
<h6 id="annotationscomments-7">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This function takes a code object and the entire code string as input and attempts to find the correct line number for each code snippet within the code object. It iterates through each code object, splits the code snippet into lines, and uses a fuzzy matching algorithm to find the starting line number in the entire code string. The function updates the <code>codeLine</code> property of each code object with the found line number or -2 if the line number could not be determined.</li>
<li><strong>Parameters:</strong> - <code>codeObj</code>: A <code>CodeObject</code> containing code snippets and other information.</li>
<li><code>code</code>: A string representing the entire code to search.</li>
<li><strong>Returns:</strong> The input <code>CodeObject</code> with the updated <code>codeLine</code> property for each code snippet.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const codeObject = {
  name: 'myFunction',
  type: 'function',
  codeSnippet: 'function myFunction() { ... }',
  codeLine: undefined,
};

const code = `// This is a chunk of code
function myFunction() { ... }
`;

const updatedCodeObject = findCorrectCodeLineForObject(codeObject, code);

console.log(updatedCodeObject.codeLine); // Output: 2
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> The fuzzy matching algorithm might not be able to find the exact line number if the code snippet is not a perfect match or if the code has been modified since the code snippet was extracted.</li>
<li><strong>Dependencies:</strong> None</li>
</ul>
<h2 id="getignoredfilesfunction">### 🔧 getIgnoredFiles - FUNCTION</h2>
<p><strong>Description:</strong> Get ignored files from .gitignore and .fofoignore</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">async function getIgnoredFiles(projectPath: string): Promise&lt;string[]&gt; {
  let ignorePatterns: string[] = [];
  const basePath = projectPath.split("/").slice(0, -1).join("/");
  const executionPath = process.cwd();

  console.log("basePath", basePath);
  console.log("executionPath", executionPath);

  // CHECK for these files in order:
  const pathsToCheck = [
    `${basePath}/.gitignore`,
    `${basePath}/.fofoignore`,
    `${executionPath}/.gitignore`,
    `${executionPath}/.fofoignore`,
  ];

  for (const path of pathsToCheck) {
    if (path.includes("fofoignore")) {
      try {
        const fofoignoreContent = await readFile(
          path,
          "utf-8"
        );
        ignorePatterns.push(...fofoignoreContent.split("\n").filter(Boolean));
      } catch (err) {
        // .fofoignore not found, ignore the error
        console.warn("No .fofoignore file found in " + path);
      }
    } else {
      try {
        const gitignoreContent = await readFile(
          path,
          "utf-8"
        );
        ignorePatterns.push(...gitignoreContent.split("\n").filter(Boolean)); // Filter out empty lines
      } catch (err) {
        // .gitignore not found, ignore the error
        console.warn("No .gitignore file found in " + path);
      }
    }
  }

  return ignorePatterns;
}
</code></pre>
<ul>
<li><strong>Line:</strong> 624</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> false</li>
<li><strong>Private:</strong> false</li>
<li><strong>Async:</strong> true</li>
</ul>
<h6 id="functionparameters-5">Function Parameters:</h6>
<ul>
<li><strong>projectPath</strong> (string): The path to the project 
Example: './src'</li>
</ul>
<h6 id="functionreturns-5">Function Returns:</h6>
<ul>
<li><strong>Type:</strong> Promise<string[]></li>
<li><strong>Description:</strong> A promise that resolves to an array of ignored files</li>
<li><strong>Example:</strong> ['node_modules', 'dist']</li>
</ul>
<h6 id="annotationscomments-8">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This function retrieves ignored files from <code>.gitignore</code> and <code>.fofoignore</code> files within the project directory or the execution directory.</li>
<li><strong>Parameters:</strong> projectPath: string - The path to the project directory.</li>
<li><strong>Returns:</strong> Promise<string[]> - A promise that resolves to an array of strings representing the ignored file patterns.</li>
<li><strong>Edge Cases:</strong> If no <code>.gitignore</code> or <code>.fofoignore</code> files are found, the function will return an empty array. The function prioritizes files within the project directory over the execution directory.</li>
<li><strong>Dependencies:</strong> fs/promises, process.cwd</li>
</ul>
<h2 id="getfilesizeinkbfunction">### 🔧 getFileSizeInKB - FUNCTION</h2>
<p><strong>Description:</strong> Get the file size in KB</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">async function getFileSizeInKB(filePath: string): Promise&lt;number&gt; {
  return await stat(filePath).then((stats) =&gt; stats.size / 1024);
}
</code></pre>
<ul>
<li><strong>Line:</strong> 669</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> false</li>
<li><strong>Private:</strong> false</li>
<li><strong>Async:</strong> true</li>
</ul>
<h6 id="functionparameters-6">Function Parameters:</h6>
<ul>
<li><strong>filePath</strong> (string): The path to the file 
Example: './src/codeParser.ts'</li>
</ul>
<h6 id="functionreturns-6">Function Returns:</h6>
<ul>
<li><strong>Type:</strong> Promise<number></li>
<li><strong>Description:</strong> A promise that resolves to the file size in KB</li>
<li><strong>Example:</strong> 1024</li>
</ul>
<h6 id="annotationscomments-9">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This function retrieves the size of a file in kilobytes (KB) using the <code>stat</code> function from the <code>fs/promises</code> module.</li>
<li><strong>Parameters:</strong> - <code>filePath</code>: A string representing the path to the file.</li>
<li><strong>Returns:</strong> - <code>Promise&lt;number&gt;</code>: A promise that resolves to the file size in KB.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const fileSizeKB = await getFileSizeInKB('./src/codeParser.ts');
console.log(`File size: ${fileSizeKB} KB`);
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> If the file does not exist or cannot be accessed, the promise will reject with an error.</li>
<li><strong>Dependencies:</strong> - <code>fs/promises</code> module for file system operations.</li>
</ul>
<h2 id="isfiletoolargefunction">### 🔧 isFileTooLarge - FUNCTION</h2>
<p><strong>Description:</strong> Check if the file is too large</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">async function isFileTooLarge(
  filePath: string,
  maxFileSizeKB: number,
  maxChars: number = 300
): Promise&lt;boolean&gt; {
  // Check the amount of characters in the file content
  const file = readFileSync(filePath, "utf-8");
  const tooLong = getTokens(file) &gt; maxChars;

  if (tooLong === true) return true;

  return await getFileSizeInKB(filePath).then((size) =&gt; size &gt; maxFileSizeKB);
}
</code></pre>
<ul>
<li><strong>Line:</strong> 673</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> false</li>
<li><strong>Private:</strong> false</li>
<li><strong>Async:</strong> true</li>
</ul>
<h6 id="functionparameters-7">Function Parameters:</h6>
<ul>
<li><strong>filePath</strong> (string): The path to the file 
Example: './src/codeParser.ts'</li>
<li><strong>maxFileSizeKB</strong> (number): The maximum file size in KB 
Example: 1024</li>
<li><strong>maxChars</strong> (number): The maximum number of characters in the file 
Example: 300</li>
</ul>
<h6 id="functionreturns-7">Function Returns:</h6>
<ul>
<li><strong>Type:</strong> Promise<boolean></li>
<li><strong>Description:</strong> A promise that resolves to true if the file is too large, false otherwise</li>
<li><strong>Example:</strong> true</li>
</ul>
<h6 id="annotationscomments-10">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This function checks if a file is too large based on two criteria: file size in KB and the number of characters in the file content.</li>
<li><strong>Parameters:</strong> - filePath: string - The path to the file.</li>
<li>maxFileSizeKB: number - The maximum file size allowed in KB.</li>
<li>maxChars: number - The maximum number of characters allowed in the file. Defaults to 300.</li>
<li><strong>Returns:</strong> A Promise that resolves to true if the file is too large (exceeds either the maximum file size or the maximum number of characters), and false otherwise.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const isLarge = await isFileTooLarge('./myFile.txt', 1024, 500);
console.log(isLarge); // true if the file is too large, false otherwise
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> The function uses <code>readFileSync</code> to read the file content, which might be inefficient for very large files. It also uses a simple character count to approximate the number of tokens, which might not be accurate for all languages.</li>
<li><strong>Dependencies:</strong> - <code>readFileSync</code> from <code>fs</code> module</li>
<li><code>getFileSizeInKB</code> function (presumably defined elsewhere)</li>
</ul>
<h2 id="types">types</h2>
<h2 id="codefilesummarytype">### 🏷️ CodeFileSummary - TYPE</h2>
<p><strong>Description:</strong> Interface for summarizing a code file.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import {  Embeddings, Metadata, QueryResponse } from "chromadb";

export type CodeObjectType = 'class' | 'function' | 'variable' | 'type' | 'import' | 'export' | 'interface' | 'constructor';
export type CodeObjects = 'classes' | 'functions' | 'variables' | 'types' | 'imports' | 'exports' | 'interfaces' | 'fileName' | 'fileLocation'

export interface globResult {

        "glob": string[],
        "ignore": string[]

}

export interface runtimeData {

    appVersion: string;
    projectName: string;
    projectPath: string;
    outputPath: string;
    selectedLLModel: string | undefined;
    selectedRAGService: string;
}
export interface moduleObject {
    name: string;
    version: string;
    description: string;
}
export interface ProjectSummary {
    projectName: string;
    projectDescription: codeSummary
    projectLocation: string;
    projectTechStackDescription: string,
    projectDependencies: moduleObject[];
    codeFiles: CodeFileSummary[];
    ragData: RagData[];
    teamContext: string;
}

export interface models {
    name: string,
    model: any,
}
export interface modelServiceConfig {
    models: models[],
    endpoint?:string 
}

export interface RagData {
    metadata: {
        filename: string;
        codeChunkId: string|number;
        codeChunkLineStart: number;
        codeChunkLineEnd: number;
        codeObjects: CodeObject;
        codeChunkSummary: string;
    };
    embeddings?: number[][]; // Example: Embeddings could be an array of numbers
    documentData: any
    allSearchResults: QueryResponse,
    allResults: {
        documents: any,
        embeddings: Embeddings[] | null,
        metadatas: (Metadata | null)[][],

    }
}

export interface codeSummary {
    goal: string,
    features_functions: string,
  }
export interface CodeFileSummary {
    fileName: string;
    fileLocation: string;
    codeSummary: codeSummary;
    language: string;
    executionFlow: ExecutionFlow[];
    codeObjects: CodeObject;
}

export interface ExecutionFlow {
    step: number;
    stepDescription: string;
    bImportant: boolean;
    codeSnippet: string;
    codeLine: number;
    codeIndent: number;
    fileName: string;
    fileLocation: string;
}

export interface FunctionParameter {
    name: string;
    type: string;
    description: string;
    example: string;
}

export interface FunctionReturn {
    type: string;
    description: string;
    example: string;
}

export interface CodeObject {
    name: string;
    type: CodeObjectType;
    description: string;
    codeSnippet: string;
    annotation?: Annotation;
    codeLine?: number;
    codeIndent?: number;
    content?:string;
    fileName: string;
    fileLocation: string;
    subObjects?: CodeObject[];
    parentObject?: CodeObject;
    functionParameters?: FunctionParameter[];
    functionReturns?: FunctionReturn;
    isExported: boolean;
    isFunction: boolean;
    isClass: boolean;
    isPrivate: boolean;
    isAsync: boolean;
}

export type CodeObjectTypes = 'name' | 'type' | 'description' | 'codeSnippet' | 'codeLine' | 'codeIndent' | 'fileName' | 'fileLocation' | 'subObjects' | 'parentObject' | 'functionParameters' | 'functionReturns' | 'isExported' | 'isFunction' | 'isClass' | 'isPrivate' | 'isAsync'

export interface Annotation {
    purpose: string;
    parameters?: string;
    returns?: string;
    usageExample?: string;
    edgeCases?: string;
    dependencies?: string;
    errorHandling?: string;
    performance?: string;
    bestPractices?: string;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-11">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>CodeFileSummary</code> interface is used to represent and store information about a code file within a project. It includes details like the file name, location, language, a summary of the code's purpose and features, and a list of code objects (classes, functions, variables, etc.) found within the file.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const codeFileSummary: CodeFileSummary = {
  fileName: "myFile.ts",
  fileLocation: "./myFile.ts",
  codeSummary: {
    goal: "This file implements a function to calculate the sum of two numbers.",
    features_functions: "The file includes a function called `add` that takes two numbers as input and returns their sum."
  },
  language: "TypeScript",
  executionFlow: [],
  codeObjects: {
    functions: [
      {
        name: "add",
        type: "function",
        description: "Calculates the sum of two numbers.",
        codeSnippet: "function add(a: number, b: number): number { return a + b; }",
        codeLine: 10,
        codeIndent: 2,
        fileName: "myFile.ts",
        fileLocation: "./myFile.ts",
        isExported: true,
        isPrivate: false,
        isAsync: false,
        functionParameters: [
          { name: "a", type: "number", description: "The first number to add.", example: "1" },
          { name: "b", type: "number", description: "The second number to add.", example: "2" }
        ],
        functionReturns: { type: "number", description: "The sum of the two input numbers.", example: "3" }
      }
    ]
  }
};
</code></pre>
<ul>
<li><strong>Dependencies:</strong> The interface relies on the <code>codeSummary</code> and <code>CodeObject</code> interfaces for representing code summaries and individual code objects, respectively.</li>
</ul>
<h2 id="codeobjecttype">### 🏷️ CodeObject - TYPE</h2>
<p><strong>Description:</strong> Interface for representing a code object.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import {  Embeddings, Metadata, QueryResponse } from "chromadb";

export type CodeObjectType = 'class' | 'function' | 'variable' | 'type' | 'import' | 'export' | 'interface' | 'constructor';
export type CodeObjects = 'classes' | 'functions' | 'variables' | 'types' | 'imports' | 'exports' | 'interfaces' | 'fileName' | 'fileLocation'

export interface globResult {

        "glob": string[],
        "ignore": string[]

}

export interface runtimeData {

    appVersion: string;
    projectName: string;
    projectPath: string;
    outputPath: string;
    selectedLLModel: string | undefined;
    selectedRAGService: string;
}
export interface moduleObject {
    name: string;
    version: string;
    description: string;
}
export interface ProjectSummary {
    projectName: string;
    projectDescription: codeSummary
    projectLocation: string;
    projectTechStackDescription: string,
    projectDependencies: moduleObject[];
    codeFiles: CodeFileSummary[];
    ragData: RagData[];
    teamContext: string;
}

export interface models {
    name: string,
    model: any,
}
export interface modelServiceConfig {
    models: models[],
    endpoint?:string 
}

export interface RagData {
    metadata: {
        filename: string;
        codeChunkId: string|number;
        codeChunkLineStart: number;
        codeChunkLineEnd: number;
        codeObjects: CodeObject;
        codeChunkSummary: string;
    };
    embeddings?: number[][]; // Example: Embeddings could be an array of numbers
    documentData: any
    allSearchResults: QueryResponse,
    allResults: {
        documents: any,
        embeddings: Embeddings[] | null,
        metadatas: (Metadata | null)[][],

    }
}

export interface codeSummary {
    goal: string,
    features_functions: string,
  }
export interface CodeFileSummary {
    fileName: string;
    fileLocation: string;
    codeSummary: codeSummary;
    language: string;
    executionFlow: ExecutionFlow[];
    codeObjects: CodeObject;
}

export interface ExecutionFlow {
    step: number;
    stepDescription: string;
    bImportant: boolean;
    codeSnippet: string;
    codeLine: number;
    codeIndent: number;
    fileName: string;
    fileLocation: string;
}

export interface FunctionParameter {
    name: string;
    type: string;
    description: string;
    example: string;
}

export interface FunctionReturn {
    type: string;
    description: string;
    example: string;
}

export interface CodeObject {
    name: string;
    type: CodeObjectType;
    description: string;
    codeSnippet: string;
    annotation?: Annotation;
    codeLine?: number;
    codeIndent?: number;
    content?:string;
    fileName: string;
    fileLocation: string;
    subObjects?: CodeObject[];
    parentObject?: CodeObject;
    functionParameters?: FunctionParameter[];
    functionReturns?: FunctionReturn;
    isExported: boolean;
    isFunction: boolean;
    isClass: boolean;
    isPrivate: boolean;
    isAsync: boolean;
}

export type CodeObjectTypes = 'name' | 'type' | 'description' | 'codeSnippet' | 'codeLine' | 'codeIndent' | 'fileName' | 'fileLocation' | 'subObjects' | 'parentObject' | 'functionParameters' | 'functionReturns' | 'isExported' | 'isFunction' | 'isClass' | 'isPrivate' | 'isAsync'

export interface Annotation {
    purpose: string;
    parameters?: string;
    returns?: string;
    usageExample?: string;
    edgeCases?: string;
    dependencies?: string;
    errorHandling?: string;
    performance?: string;
    bestPractices?: string;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-12">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>CodeObject</code> interface defines the structure for representing code objects within a project. It includes properties like <code>name</code>, <code>type</code>, <code>description</code>, <code>codeSnippet</code>, <code>annotation</code>, <code>codeLine</code>, <code>codeIndent</code>, <code>fileName</code>, <code>fileLocation</code>, <code>subObjects</code>, <code>parentObject</code>, <code>functionParameters</code>, <code>functionReturns</code>, <code>isExported</code>, <code>isFunction</code>, <code>isClass</code>, <code>isPrivate</code>, and <code>isAsync</code>. This interface is used to store and organize information about code elements, such as classes, functions, variables, types, imports, exports, and interfaces.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const codeObject: CodeObject = {
  name: 'myFunction',
  type: 'function',
  description: 'This function does something',
  codeSnippet: 'function myFunction() { ... }',
  codeLine: 10,
  codeIndent: 2,
  fileName: 'myFile.ts',
  fileLocation: './myFile.ts',
  isExported: true,
  isFunction: true,
  isClass: false,
  isPrivate: false,
  isAsync: false
};
</code></pre>
<ul>
<li><strong>Dependencies:</strong> The <code>CodeObject</code> interface relies on the <code>CodeObjectType</code> and <code>CodeObjects</code> types, as well as the <code>Annotation</code> interface, which are also defined in the <code>objectSchemas.ts</code> file.</li>
</ul>
<h2 id="modelserviceconfigtype">### 🏷️ modelServiceConfig - TYPE</h2>
<p><strong>Description:</strong> Interface for representing a model service configuration.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import {  Embeddings, Metadata, QueryResponse } from "chromadb";

export type CodeObjectType = 'class' | 'function' | 'variable' | 'type' | 'import' | 'export' | 'interface' | 'constructor';
export type CodeObjects = 'classes' | 'functions' | 'variables' | 'types' | 'imports' | 'exports' | 'interfaces' | 'fileName' | 'fileLocation'

export interface globResult {

        "glob": string[],
        "ignore": string[]

}

export interface runtimeData {

    appVersion: string;
    projectName: string;
    projectPath: string;
    outputPath: string;
    selectedLLModel: string | undefined;
    selectedRAGService: string;
}
export interface moduleObject {
    name: string;
    version: string;
    description: string;
}
export interface ProjectSummary {
    projectName: string;
    projectDescription: codeSummary
    projectLocation: string;
    projectTechStackDescription: string,
    projectDependencies: moduleObject[];
    codeFiles: CodeFileSummary[];
    ragData: RagData[];
    teamContext: string;
}

export interface models {
    name: string,
    model: any,
}
export interface modelServiceConfig {
    models: models[],
    endpoint?:string 
}

export interface RagData {
    metadata: {
        filename: string;
        codeChunkId: string|number;
        codeChunkLineStart: number;
        codeChunkLineEnd: number;
        codeObjects: CodeObject;
        codeChunkSummary: string;
    };
    embeddings?: number[][]; // Example: Embeddings could be an array of numbers
    documentData: any
    allSearchResults: QueryResponse,
    allResults: {
        documents: any,
        embeddings: Embeddings[] | null,
        metadatas: (Metadata | null)[][],

    }
}

export interface codeSummary {
    goal: string,
    features_functions: string,
  }
export interface CodeFileSummary {
    fileName: string;
    fileLocation: string;
    codeSummary: codeSummary;
    language: string;
    executionFlow: ExecutionFlow[];
    codeObjects: CodeObject;
}

export interface ExecutionFlow {
    step: number;
    stepDescription: string;
    bImportant: boolean;
    codeSnippet: string;
    codeLine: number;
    codeIndent: number;
    fileName: string;
    fileLocation: string;
}

export interface FunctionParameter {
    name: string;
    type: string;
    description: string;
    example: string;
}

export interface FunctionReturn {
    type: string;
    description: string;
    example: string;
}

export interface CodeObject {
    name: string;
    type: CodeObjectType;
    description: string;
    codeSnippet
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> undefined (Unable to Load)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-13">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>modelServiceConfig</code> interface defines the configuration for a model service, including an array of models and an optional endpoint.</li>
<li><strong>Parameters:</strong>  - <code>models</code>: An array of <code>models</code> objects, each representing a specific model with its name and associated model object. </li>
<li><code>endpoint</code>: An optional string representing the endpoint URL for the model service.</li>
<li><strong>Returns:</strong> This interface does not return any value. It is used to define the structure of a model service configuration.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const modelServiceConfig: modelServiceConfig = {
  models: [
    {
      name: "phi3",
      model: "phi3",
    },
  ],
  endpoint: "http://localhost:11434",
};
</code></pre>
<ul>
<li><strong>Dependencies:</strong>  - <code>models</code> interface: Defines the structure of individual model objects within the configuration. </li>
<li><code>Embeddings</code>, <code>Metadata</code>, <code>QueryResponse</code>: Types imported from the <code>chromadb</code> library, likely used for vector database operations.</li>
</ul>
<h2 id="imports">imports</h2>
<h2 id="globimport">### 📥 glob - IMPORT</h2>
<p><strong>Description:</strong> Imports the glob function from the glob module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import { glob } from "glob";
</code></pre>
<ul>
<li><strong>Line:</strong> 1</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-14">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> Imports the <code>glob</code> function from the <code>glob</code> module, which is used for finding files matching a specified pattern.</li>
<li><strong>Dependencies:</strong> glob module</li>
</ul>
<h2 id="loggerimport">### 📥 logger - IMPORT</h2>
<p><strong>Description:</strong> Imports the logger module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import "./logger";
</code></pre>
<ul>
<li><strong>Line:</strong> 2</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-15">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This line imports the <code>logger</code> module, which is likely responsible for logging messages and events within the application.</li>
<li><strong>Dependencies:</strong> The <code>logger</code> module is a dependency of this code.</li>
</ul>
<h2 id="readfileimport">### 📥 readFile - IMPORT</h2>
<p><strong>Description:</strong> Imports the readFile function from the fs/promises module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import { readFile, stat } from "fs/promises";
</code></pre>
<ul>
<li><strong>Line:</strong> 3</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-16">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This code imports the <code>readFile</code> function from the <code>fs/promises</code> module, which allows asynchronous reading of files.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const fileContent = await readFile("path/to/file.txt", "utf-8");
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> The <code>readFile</code> function can throw an error if the file does not exist or if there is an error reading the file.</li>
<li><strong>Dependencies:</strong> fs/promises module</li>
</ul>
<h2 id="codefilesummaryimport">### 📥 CodeFileSummary - IMPORT</h2>
<p><strong>Description:</strong> Imports the CodeFileSummary interface from the objectSchemas module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import {
  CodeFileSummary,
  CodeObject,
  CodeObjects,
  ProjectSummary,
  RagData,
  codeSummary,
  globResult,
  moduleObject,
} from "./objectSchemas";
</code></pre>
<ul>
<li><strong>Line:</strong> 4</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-17">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This code snippet imports the <code>CodeFileSummary</code> interface from the <code>objectSchemas</code> module, along with other related interfaces and types.</li>
<li><strong>Dependencies:</strong> objectSchemas module</li>
</ul>
<h2 id="inferimport">### 📥 infer - IMPORT</h2>
<p><strong>Description:</strong> Imports the infer function from the llmInterface module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import { infer, callLLM, getCodeSummaryFromLLM } from "./llmInterface";
</code></pre>
<ul>
<li><strong>Line:</strong> 14</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-18">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This import statement brings in the <code>infer</code> function from the <code>llmInterface</code> module. The <code>infer</code> function is likely used to interact with a large language model (LLM) to get information or generate text based on a given prompt.</li>
<li><strong>Dependencies:</strong> llmInterface module</li>
</ul>
<h2 id="getlanguagetypefromfileimport">### 📥 getLanguageTypeFromFile - IMPORT</h2>
<p><strong>Description:</strong> Imports the getLanguageTypeFromFile function from the prompt module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import { 
    getLanguageTypeFromFile, 
    classesPrompt,
    functionsPrompt,
    variablesPrompt,
    typesPrompt,
    interfacesPrompt,
    // commentsPrompt,
    importsPrompt,
    exportsPrompt,
    determineProjectStack,
    getPackageDependenciesBasedOnLanguage,
    determineModulesPackagesFromFile,
    getGlobsBasedOnLangStack
 } from "./prompt";
</code></pre>
<ul>
<li><strong>Line:</strong> 15</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-19">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This code snippet imports the <code>getLanguageTypeFromFile</code> function from the <code>prompt</code> module.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const language = getLanguageTypeFromFile('./src/codeParser.ts');
</code></pre>
<ul>
<li><strong>Dependencies:</strong> prompt module</li>
</ul>
<h2 id="savetovectordatabaseimport">### 📥 saveToVectorDatabase - IMPORT</h2>
<p><strong>Description:</strong> Imports the saveToVectorDatabase function from the vectorDB module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import { saveToVectorDatabase } from "./vectorDB";
</code></pre>
<ul>
<li><strong>Line:</strong> 30</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-20">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This code object imports the <code>saveToVectorDatabase</code> function from the <code>vectorDB</code> module, which is likely used to store code snippets in a vector database for later retrieval and analysis.</li>
<li><strong>Dependencies:</strong> vectorDB module</li>
</ul>
<h2 id="breakcodeintochunksimport">### 📥 breakCodeIntoChunks - IMPORT</h2>
<p><strong>Description:</strong> Imports the breakCodeIntoChunks function from the shared module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import { breakCodeIntoChunks, cleanBackticks, getContextFromFile, getFileContentLen, getTokens, getTotalLines, isArray, removeCodeBlockIfPresent } from "./shared";
</code></pre>
<ul>
<li><strong>Line:</strong> 31</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-21">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This code object imports the <code>breakCodeIntoChunks</code> function from the <code>shared</code> module.</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const codeChunks = breakCodeIntoChunks(code, chunkSize);
</code></pre>
<ul>
<li><strong>Dependencies:</strong> The <code>breakCodeIntoChunks</code> function is defined in the <code>shared</code> module.</li>
</ul>
<h2 id="fsimport">### 📥 fs - IMPORT</h2>
<p><strong>Description:</strong> Imports the fs module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import fs from "fs";
</code></pre>
<ul>
<li><strong>Line:</strong> 32</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-22">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This code object imports the <code>fs</code> module from Node.js, providing access to file system operations.</li>
<li><strong>Dependencies:</strong> Node.js <code>fs</code> module</li>
</ul>
<h2 id="dotenvconfigimport">### 📥 dotenv/config - IMPORT</h2>
<p><strong>Description:</strong> Imports the config function from the dotenv module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import "dotenv/config";
</code></pre>
<ul>
<li><strong>Line:</strong> 33</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-23">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This line imports the <code>config</code> function from the <code>dotenv</code> module, which is used to load environment variables from a <code>.env</code> file.</li>
<li><strong>Dependencies:</strong> dotenv</li>
</ul>
<h2 id="readfilesyncimport">### 📥 readFileSync - IMPORT</h2>
<p><strong>Description:</strong> Imports the readFileSync function from the fs module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import { readFileSync } from "fs";
</code></pre>
<ul>
<li><strong>Line:</strong> 34</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-24">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This code object imports the <code>readFileSync</code> function from the <code>fs</code> module, which is used to read the contents of a file synchronously.</li>
<li><strong>Parameters:</strong> None</li>
<li><strong>Returns:</strong> None</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const fileContent = fs.readFileSync("path/to/file.txt", "utf-8");
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> If the file does not exist or cannot be read, an error will be thrown.</li>
<li><strong>Dependencies:</strong> fs module</li>
</ul>
<h2 id="readlineimport">### 📥 readline - IMPORT</h2>
<p><strong>Description:</strong> Imports the readline module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import readline from 'readline'
</code></pre>
<ul>
<li><strong>Line:</strong> 40</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-25">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This code imports the <code>readline</code> module, which provides an interface for reading data from the command line.</li>
<li><strong>Dependencies:</strong> readline</li>
</ul>
<h2 id="fofodocsbuiltinfilesearchimport">### 📥 fofoDocsBuiltInFileSearch - IMPORT</h2>
<p><strong>Description:</strong> Imports the fofoDocsBuiltInFileSearch array from the appData module.</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">import { fofoDocsBuiltInFileSearch, fofoDocsBuiltInGlobSearch, isNoNoFile } from "./appData";
</code></pre>
<ul>
<li><strong>Line:</strong> 41</li>
<li><strong>Location:</strong> codeParser.ts (./src/codeParser.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-26">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This code object imports the <code>fofoDocsBuiltInFileSearch</code> array from the <code>appData</code> module. This array contains a list of file extensions and patterns that are considered relevant for documentation generation.</li>
<li><strong>Dependencies:</strong> appData module</li>
</ul>
<h2 id="interfaces">interfaces</h2>
<h2 id="globresultinterface">### 🌉 globResult - INTERFACE</h2>
<p><strong>Description:</strong> N/A</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">interface globResult {

        "glob": string[],
        "ignore": string[]

}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./src/objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-27">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This interface defines the structure for a result object returned by the <code>glob</code> function, which is used to find files matching a pattern.</li>
</ul>
<h2 id="moduleobjectinterface">### 🌉 moduleObject - INTERFACE</h2>
<p><strong>Description:</strong> N/A</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">interface moduleObject {
    name: string;
    version: string;
    description: string;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./src/objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-28">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This interface defines the structure for a module object, which represents a package or module with its name, version, and description.</li>
</ul>
<h2 id="modelsinterface">### 🌉 models - INTERFACE</h2>
<p><strong>Description:</strong> N/A</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">interface models {
    name: string,
    model: any,
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./src/objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-29">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This interface defines the structure for a model object, which likely represents a language model or a machine learning model.</li>
<li><strong>Parameters:</strong> N/A</li>
<li><strong>Returns:</strong> N/A</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const myModel: models = {
    name: "myModel",
    model: "someModelObject"
};
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> N/A</li>
<li><strong>Dependencies:</strong> N/A</li>
</ul>
<h2 id="modelserviceconfiginterface">### 🌉 modelServiceConfig - INTERFACE</h2>
<p><strong>Description:</strong> N/A</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">interface modelServiceConfig {
    models: models[],
    endpoint?:string 
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./src/objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-30">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This interface defines the configuration for a model service, including the models and optional endpoint.</li>
<li><strong>Parameters:</strong> models: models[],
endpoint?:string</li>
<li><strong>Returns:</strong> N/A</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const modelServiceConfig: modelServiceConfig = {
    models: [
        { name: 'gpt-3.5-turbo', model: 'gpt-3.5-turbo' },
        { name: 'gpt-4', model: 'gpt-4' }
    ],
    endpoint: 'https://api.openai.com/v1'
};
</code></pre>
<h2 id="ragdatainterface">### 🌉 RagData - INTERFACE</h2>
<p><strong>Description:</strong> N/A</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">interface RagData {
    metadata: {
        filename: string;
        codeChunkId: string|number;
        codeChunkLineStart: number;
        codeChunkLineEnd: number;
        codeObjects: CodeObject;
        codeChunkSummary: string;
    };
    embeddings?: number[][]; // Example: Embeddings could be an array of numbers
    documentData: any
    allSearchResults: QueryResponse,
    allResults: {
        documents: any,
        embeddings: Embeddings[] | null,
        metadatas: (Metadata | null)[][],

    }
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./src/objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-31">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>RagData</code> interface defines the structure for storing data related to a code chunk, including metadata, embeddings, document data, and search results from a vector database.</li>
<li><strong>Dependencies:</strong> This interface depends on the <code>CodeObject</code>, <code>QueryResponse</code>, <code>Embeddings</code>, and <code>Metadata</code> types.</li>
</ul>
<h2 id="executionflowinterface">### 🌉 ExecutionFlow - INTERFACE</h2>
<p><strong>Description:</strong> N/A</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">interface ExecutionFlow {
    step: number;
    stepDescription: string;
    bImportant: boolean;
    codeSnippet: string;
    codeLine: number;
    codeIndent: number;
    fileName: string;
    fileLocation: string;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./src/objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-32">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>ExecutionFlow</code> interface defines the structure for representing a step in the execution flow of a codebase. It includes information about the step number, description, importance, code snippet, line number, indentation level, and file location.</li>
<li><strong>Parameters:</strong> N/A</li>
<li><strong>Returns:</strong> N/A</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const executionFlow: ExecutionFlow = {
    step: 1,
    stepDescription: "This is the first step in the execution flow",
    bImportant: true,
    codeSnippet: "// Code snippet for the first step",
    codeLine: 10,
    codeIndent: 2,
    fileName: "myFile.ts",
    fileLocation: "./src/myFile.ts"
};
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> N/A</li>
<li><strong>Dependencies:</strong> N/A</li>
</ul>
<h2 id="functionparameterinterface">### 🌉 FunctionParameter - INTERFACE</h2>
<p><strong>Description:</strong> N/A</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">interface FunctionParameter {
    name: string;
    type: string;
    description: string;
    example: string;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./src/objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-33">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This interface defines the structure of a function parameter object.</li>
<li><strong>Parameters:</strong>  - <strong>name</strong>: string - The name of the parameter.</li>
<li><strong>type</strong>: string - The data type of the parameter.</li>
<li><strong>description</strong>: string - A description of the parameter.</li>
<li><strong>example</strong>: string - An example value for the parameter.</li>
<li><strong>Returns:</strong> N/A</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const param: FunctionParameter = {
    name: "myParam",
    type: "string",
    description: "This is a parameter",
    example: "Hello World"
};
</code></pre>
<ul>
<li><strong>Dependencies:</strong> N/A</li>
</ul>
<h2 id="functionreturninterface">### 🌉 FunctionReturn - INTERFACE</h2>
<p><strong>Description:</strong> N/A</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">interface FunctionReturn {
    type: string;
    description: string;
    example: string;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./src/objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-34">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> This interface defines the structure for a function's return value, including its type, description, and an example.</li>
</ul>
<h2 id="codeobjectinterface">### 🌉 CodeObject - INTERFACE</h2>
<p><strong>Description:</strong> N/A</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">interface CodeObject {
    name: string;
    type: CodeObjectType;
    description: string;
    codeSnippet: string;
    annotation?: Annotation;
    codeLine?: number;
    codeIndent?: number;
    content?:string;
    fileName: string;
    fileLocation: string;
    subObjects?: CodeObject[];
    parentObject?: CodeObject;
    functionParameters?: FunctionParameter[];
    functionReturns?: FunctionReturn;
    isExported: boolean;
    isFunction: boolean;
    isClass: boolean;
    isPrivate: boolean;
    isAsync: boolean;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./src/objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-35">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>CodeObject</code> interface defines the structure for representing code objects within a project. It includes information about the object's name, type, description, code snippet, annotations, line number, indentation, file location, sub-objects, parent object, function parameters, return values, and various flags indicating its properties (exported, function, class, private, async).</li>
<li><strong>Parameters:</strong> N/A</li>
<li><strong>Returns:</strong> N/A</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const codeObject: CodeObject = {
    name: "myFunction",
    type: "function",
    description: "This function does something",
    codeSnippet: "// Code snippet here",
    codeLine: 10,
    fileName: "myFile.ts",
    fileLocation: "./src/myFile.ts",
    isExported: true,
    isFunction: true,
    isClass: false,
    isPrivate: false,
    isAsync: false
};
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> N/A</li>
<li><strong>Dependencies:</strong> N/A</li>
</ul>
<h2 id="annotationinterface">### 🌉 Annotation - INTERFACE</h2>
<p><strong>Description:</strong> N/A</p>
<p><strong>Code Snippet:</strong></p>
<pre><code class="typescript language-typescript">interface Annotation {
    purpose: string;
    parameters?: string;
    returns?: string;
    usageExample?: string;
    edgeCases?: string;
    dependencies?: string;
    errorHandling?: string;
    performance?: string;
    bestPractices?: string;
}
</code></pre>
<ul>
<li><strong>Line:</strong> Could Not Verify Line</li>
<li><strong>Location:</strong> objectSchemas.ts (./src/objectSchemas.ts)</li>
<li><strong>Exported:</strong> Could Not Determine</li>
<li><strong>Private:</strong> Could Not Determine</li>
</ul>
<h6 id="annotationscomments-36">Annotations / Comments:</h6>
<ul>
<li><strong>Purpose:</strong> The <code>Annotation</code> interface defines the structure for annotations that can be applied to code objects. It includes properties for describing the purpose, parameters, returns, usage examples, edge cases, dependencies, error handling, performance considerations, and best practices for using the code object.</li>
<li><strong>Parameters:</strong> N/A</li>
<li><strong>Returns:</strong> N/A</li>
<li><strong>Usage Example:</strong> </li>
</ul>
<pre><code class="typescript language-typescript">const annotation: Annotation = {
    purpose: "This function calculates the sum of two numbers",
    parameters: "num1: number, num2: number",
    returns: "number",
    usageExample: "
</code></pre>
<p>typescript\nconst sum = add(1, 2);\n</p>
<pre><code class="", language-",">    edgeCases: "Negative numbers are not supported",
    dependencies: "someDependency, anotherDependency",
    errorHandling: "Throws an error if the input is not a number",
    performance: "Optimized for speed",
    bestPractices: "Use this function for adding numbers to"
};
</code></pre>
<ul>
<li><strong>Edge Cases:</strong> N/A</li>
<li><strong>Dependencies:</strong> N/A</li>
</ul>